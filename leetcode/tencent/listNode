ListNode的结构

struct ListNode {
      int val;  //当前结点的值
      ListNode *next;  //指向下一个结点的指针
      ListNode(int x) : val(x), next(NULL) {}  //初始化当前结点值为x,指针为空
  };

如何向ListNode中插入新的结点：从键盘输入
复制代码

ListNode* temp1 = new Solution::ListNode(0); //创建新元素，
ListNode* l1 = temp1; //最后的结果l1指向temp1，这样可以获取temp所接收的全部元素，而temp的指针由于每次都往下移，所以每次都更新

while ((c = getchar()) != '\n')   //以空格区分各个结点的值
        {
            if (c != ' ')
            {
                ungetc(c, stdin);  //把不是空格的字符丢回去
                cin >> num;
                Solution::ListNode* newnode = new Solution::ListNode(0);
                newnode->val = num;//创建新的结点存放键盘中读入的值
                newnode->next = NULL;
                temp2->next = newnode;//并将其赋值给temp2
                temp2 = newnode; //此处也可以写成  temp2=temp2->next,使指针指向下一个，以待接收新元素
            }
        }

复制代码

逆序输出所有元素
复制代码

void  Solution::reversePrintListNode(ListNode* head)
{
    if (head == nullptr) return;
     cout << head->val; //顺序输出
    reversePrintListNode(head->next);
    cout << head->val; //逆序输出

}

#include<stdio.h>
#include<stdlib.h>
#include<stdbool.h>
typedef struct LNode{
        int data;
        struct LNode* next;
}LNode, *Linklist;

//-------------------头插法建立单链表--------------------------
Linklist CreatList1(Linklist L)
{
    LNode* s;
    int x;
    L= (Linklist)malloc(sizeof(LNode));
    L->next=NULL;
    for(x=1;x<=20;x++)
    {
        s=(LNode*)malloc(sizeof(LNode));
        s->data=x;
        s->next=L->next;
        L->next=s;
    }

    return L;
}
//------------------返回第i个位置上的结点元素----------
LNode* GetElem(Linklist LL,int i)
{
    LNode* s=LL;
    while(i)
    {
        s=s->next;
        i--;
    }
    return s;

}
//------------------按值查找结点-----------------------
LNode* LocalElem(Linklist LL,int xx)
{
    LNode* s=LL->next;
    while(s)
    {
        if(s->data==xx)
            return s;
        s=s->next;
    }

}
//--------------------插入结点---------------------
void InsertNode(Linklist LL,int i,LNode* ss)
{
    LNode* s=(LNode*)malloc(sizeof(LNode));
    s=ss;
    LNode* p=LL;
    p=GetElem(LL,i-1);
    s->next=p->next;
    p->next=s;
}
//------------------删除结点---------------------
void DeleteNode(Linklist LL,int i)
{
    LNode* p=LL;
    LNode* q=NULL;
    p=GetElem(LL,i-1);
    q=p->next;
    p->next=q->next;
    free(q);

}
void printLinkList(Linklist LL)
{
    LNode* s=LL->next;
    int i=1;
    do
    {
        printf("%d ",s->data);
        s=s->next;
        i++;
    }while(s);
    printf("\n\n\n");
}

int main()
{
//--------------------创建单链表----------------------------------
    Linklist LL;
    LL=CreatList1(LL);
    printLinkList(LL);

//--------------------查找值为3的结点-----------------------------
    LNode* ss;
    ss=LocalElem(LL,3);
    printf("查找到值为%d的结点\n",ss->data);
    printf("\n\n\n");

//-------------在链表第三个位置插入结点sss--------------------
    LNode* sss=(LNode*)malloc(sizeof(LNode));
    sss->data=0;
    sss->next=NULL;
    InsertNode(LL,3,sss);
    printLinkList(LL);
//-------------删除第四个结点------------------------------------
    DeleteNode(LL,4);
    printLinkList(LL);

}
