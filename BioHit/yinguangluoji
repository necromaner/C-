bool APP_dev::agl_calc_buf(TlineClinePosStr TcPos,double *bufP, int Length, AdcCalcStr &CalcVol)
{
    //1.判断是否为AGL设备
    //2.错误判断 Length不能小于1800
    //3.
    if(isCalibration == true)       // 如果是C位置校准
    {
//        qDebug() << "C位置校准";
        double cMinVol=1000000;//最小值
        int PeakCPos=1100;//最大值的坐标
        double PeakCVol=0;//最大值
        int tMinPos=1100;//最小值的坐标
        double tMinVol=1000000;//最小值

        int PeakTPos=900;
        double PeakTVol=0;

        double Samll_Peak[180] = {0};
        int iDiff = 0;
        int iSum = 0;
        int iDex = 0;
        //将前1800组数据每10个求平均数，传到Samll_Peak中

        //Samll_Rank为Samll_Peak的60到169与后面的差值
        double Samll_Rank[179] = {0};

        QString Rank_str;//存放符合要求的数
        int c_Left = 0;
        int c_Right = 0;
        int C_Lefttimes = 0;
        int C_Righttimes = 0;
        bool isCpeakOK = false;
        bool ok = false;
        //求序号在11到170的满足要求的序号存储到Rank_str中，用;分割每个峰，用,分割每个峰中符合要求的序号

        int TC_DX =  GetPasswd("@DX").toInt(&ok);//350
        int Limit_C = GetPasswd("@LeftC").toInt(&ok);//900
        int Max_C = GetPasswd("@RightC").toInt(&ok);//1680


        QStringList CPeak_times = Rank_str.split(";");//用";"分割  ";"相隔的为符合要求的连续的点
        int Peak_Lengh = CPeak_times.length() - 1;              // 得到找到的符合范围的峰值点范围的次数
        if(0 == Peak_Lengh)                                                     // 找到0个峰
        {
//            qDebug() << "We have no found" ;
            tMinPos = 0;                                  //1  最小值的坐标（最大值与最大值坐标-350的左右180范围内的最大值之间的范围）
            tMinVol = 0;                                  //2  最小值
            PeakCPos = 0;                                 //3  求最大值的坐标（passpord中的范围）
            PeakCVol = 0;                                 //4  最大值
            cMinVol = tMinVol = 0;                        //5
        }
        else if(1 == Peak_Lengh)                                             // 找到1个峰
        {
            QString PeakData = CPeak_times.at(1);                           //获取第2组数据
            QStringList CPeak_List = PeakData.split(",");                   //用","分割
            Peak_Lengh = CPeak_List.length() - 1;
            FoundPeakVol C_Peak[Peak_Lengh];

            //将C_Peak初始化为0

            //C_Peak[0]为左侧峰值在bufP中实际位置

            Rank_Data(C_Peak, Peak_Lengh);//将C_Peak中的值从大到小进行排序

            int LeftC = C_Peak[0].Location - 20;//C_Peak左边20的坐标      最大值左边20
            int RightC = C_Peak[0].Location + 20;//C_Peak右边20的坐标     最大值右边20
            PeakCVol = 0;                                 //4  最大值
            cMinVol =1000000;                             //5
            int  C_Location = 0;           //最大值坐标
            double C_max = 0;              //最大值
            //C_max与PeakCVol得到范围中（最大值左右40的范围）的最大值  C_Location为范围中最大值坐标

            //Limit_C与Max_C为password中写的值，判断最大值是否在该范围内
            if(Limit_C <= C_Location && C_Location <= Max_C)       // 如果位置符合C线位置
            {
                tMinPos = 0;                                  //1  最小值的坐标（最大值与最大值坐标-350的左右180范围内的最大值之间的范围）
                tMinVol = 0;                                  //2  最小值
                PeakCPos = 0;                                 //3  求最大值的坐标（passpord中的范围）
                PeakCVol = 0;                                 //4  最大值
                PeakTVol = 0;        左侧最大值
                tMinVol = 1000000;   //最小值
                }
                cMinVol = tMinVol;
            }
            else                            // 如果位置不符合C线位置   范围外
            {
//                qDebug() << "The Card is Error";
                return false;
            }
        }
        else                                                                              // 找到多个峰
        {
//            qDebug() << "We have found times " <<  Peak_Lengh;
            QString CPeakstr;
            QString TPeakstr;
            double MaxData = 0;
            int MaxLocation = 0;
            for(int index = 0; index < Peak_Lengh; index++)
            {
                QString PeakC = CPeak_times.at(index+1);
                QStringList CPeak_List = PeakC.split(",");
                int Lengh = CPeak_List.length() - 1;
                FoundPeakVol C_Peak[Lengh];
                memset(C_Peak, 0, sizeof(C_Peak));
                for(int i = 0; i <  Lengh; i++)
                {
                    C_Peak[i].ReadData = bufP[CPeak_List.at(i).toInt() * 10];
                    C_Peak[i].Location = CPeak_List.at(i).toInt() * 10;
                }
                Rank_Data(C_Peak, Lengh);
                int LeftC = C_Peak[0].Location - 20;
                int RightC = C_Peak[0].Location + 20;
                PeakCVol = 0;
                cMinVol =1000000;
                int  C_Location = 0;
                for(int i = LeftC; i <= RightC; i++)
                {
                    if(bufP[i] >= PeakCVol)
                    {
                        C_Location = i;
                        PeakCVol = bufP[C_Location];
                    }
                }
                MaxData = PeakCVol;
                MaxLocation = C_Location;
                if(C_Peak[0].Location >= 1000)
                {
                    CPeakstr += QString::number(MaxLocation) + ",";
                }
                else
                {
                    TPeakstr += QString::number(MaxLocation) + ",";
                }
            }
            QStringList ListPeakC = CPeakstr.split(",");
            int CPeaktime = ListPeakC.length() - 1;
            QStringList ListPeakT = TPeakstr.split(",");
            int TPeaktime = ListPeakT.length() - 1;
            FoundPeakVol CPeakFound[CPeaktime];
            FoundPeakVol TPeakFound[TPeaktime];
            memset(CPeakFound, 0, sizeof(CPeakFound));
            memset(TPeakFound, 0, sizeof(TPeakFound));
            for(int i = 0; i < CPeaktime; i++)
            {
                CPeakFound[i].Location = ListPeakC.at(i).toInt();
                CPeakFound[i].ReadData = bufP[ListPeakC.at(i).toInt()];
            }
            for(int i = 0; i < TPeaktime; i++)
            {
                TPeakFound[i].Location = ListPeakT.at(i).toInt();
                TPeakFound[i].ReadData = bufP[ListPeakT.at(i).toInt()];
            }
            Rank_Data(CPeakFound, CPeaktime);
            Rank_Data(TPeakFound, TPeaktime);
            PeakCPos = CPeakFound[0].Location;
            PeakTPos = TPeakFound[0].Location;
//            qDebug() << "------C Location have " << PeakCPos;
//            qDebug() << "------T Location have " << PeakTPos;
//            qDebug() << "C Data have " << CPeakFound[0].ReadData;
//            qDebug() << "T Data have " << TPeakFound[0].ReadData;
//------------------------------Add-----liuyouwei---------------------------------------------------------//
            int TCDx = PeakCPos - PeakTPos;
            QString TC_Dx = QString::number(TCDx);
            if(!ReWriteFile("DX", TC_Dx))
            {
//                qDebug() << "rewite error";
            }
            int CLocation = GetPasswd("@C_Location").toInt(&ok);
            if(ok == false)
            {
                return false;
            }

            int Cdistance = CLocation - PeakCPos;
            QString CDis_str = QString::number(Cdistance);
            if(!ReWriteFile("C_Distance", CDis_str))
            {
//                qDebug() << "3518 rewite error";
            }
//--------------------------------------------------------------------------------------------------------------//
        }
    }
    else
    {
//        qDebug() << "非C线校准，读TC值";
        bool ok = false;
        //--------------------------------------------------new algorithm--------------------------//
        double cMinVol=1000000;
        int PeakCPos=1100;
        double PeakCVol=0;
        int tMinPos=1100;
        double tMinVol=1000000;
        int PeakTPos=900;
        double PeakTVol=0;
//        double Rank_Peak[1799] = {0};
//----------------------------Add----liuyouwei----------------------------------//
        int DX_c = GetPasswd("@C_Distance").toInt(&ok);
        if(DX_c < 0)
        {
            for(int i = 0; i < 1800+DX_c; i++)
            {
                bufP[i] = bufP[i-DX_c];
            }
            for(int i = 1800+DX_c; i < 1800; i++)
            {
                bufP[i] = bufP[1799+DX_c];
            }
        }
        else if(DX_c > 0)
        {
            for(int i = 1799; i > DX_c; i--)
            {
                bufP[i] = bufP[i-DX_c];
            }
            for(int i = DX_c; i > 0; i--)
            {
                bufP[i] = bufP[DX_c];
            }
        }
//-------------------------------------------------------------------------------------//
//        for(int i = 0 ; i < 1799; i++)
//        {
//            Rank_Peak[i] = bufP[i+1] - bufP[i];
//        }
        double Samll_Peak[180] = {0};
        int iDiff = 0;
        int iSum = 0;
        int iDex = 0;
        for(int i = 0; i < 180; i++)                            //   将曲线原值进行滤波处理
        {
            iDiff = 1800 - iDex;
            if(iDiff > 10)
            {
                iDiff = 10;
            }
            iSum = 0;
            for(int j = i * 10; j < i * 10 + iDiff; j++)
            {
                iSum += bufP[j];
                Samll_Peak[i] =   iSum / iDiff;
                iDex++;
            }
        }
        double Samll_Rank[179] = {0};
        for(int i = 0; i < 179; i++)                            //   得到滤波之后曲线的倒数曲线
        {
            Samll_Rank[i] = Samll_Peak[i+1] - Samll_Peak[i];
        }
        QString Rank_str;
        int c_Left = 0;
        int c_Right = 0;
        int C_Lefttimes = 0;
        int C_Righttimes = 0;
        bool isCpeakOK = false;
//        bool ok = false;
        for(int i = 168; i > 100; i--)                                            // 在滤波之后的曲线的倒数曲线寻找峰值点
        {
            C_Lefttimes = 0;
            C_Righttimes = 0;
            c_Left = i - 5;
            c_Right = i + 5;
            for(int j = c_Left; j < i; j++)
            {
                if(Samll_Rank[j] > 0)
                {
                    C_Lefttimes++;
                }
                else if(Samll_Rank[j] < 0)
                {
                    break;
                }
            }
            if(C_Lefttimes > 1)
            {
                for(int k = i; k < c_Right; k++)
                {
                    if(Samll_Rank[k] < 0)
                    {
                        C_Righttimes++;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            if(C_Righttimes > 1)
            {
                if(isCpeakOK == false)
                {
                    isCpeakOK = true;
                    Rank_str += ";";
                }
                Rank_str += QString::number(i) + ",";
            }
            else
            {
                isCpeakOK = false;
            }
        }
//        qDebug() << "We found Rank_str " << Rank_str;

        int TC_DX =  GetPasswd("@DX").toInt(&ok);
        if(ok == false)
        {
            return false;
        }
        int Limit_C = GetPasswd("@LeftC").toInt(&ok);
        if(ok == false)
        {
            return false;
        }
        int Max_C = GetPasswd("@RightC").toInt(&ok);
        if(ok == false)
        {
            return false;
        }
        QStringList CPeak_times = Rank_str.split(";");
        int Peak_Lengh = CPeak_times.length() - 1;              // 得到找到的符合范围的峰值点范围的次数
        if(0 == Peak_Lengh)                                                     // 找到0个峰
        {
//            qDebug() << "We have no found" ;
            tMinPos = 0;
            tMinVol = 0;
            PeakCPos = 0;
            PeakCVol = 0;
            cMinVol = tMinVol = 0;
        }
        else if(1 == Peak_Lengh)                                             // 找到1个峰
        {
            QString PeakData = CPeak_times.at(1);
            QStringList CPeak_List = PeakData.split(",");
            Peak_Lengh = CPeak_List.length() - 1;
            FoundPeakVol C_Peak[Peak_Lengh];
            memset(C_Peak, 0, sizeof(C_Peak));
            for(int i = 0; i <  Peak_Lengh; i++)
            {
                C_Peak[i].ReadData = bufP[CPeak_List.at(i).toInt() * 10];
                C_Peak[i].Location = CPeak_List.at(i).toInt() * 10;
            }
            Rank_Data(C_Peak, Peak_Lengh);
            int LeftC = C_Peak[0].Location - 20;
            int RightC = C_Peak[0].Location + 20;
            PeakCVol = 0;
            cMinVol =1000000;
            int  C_Location = 0;
            double C_max = 0;
            for(int i = LeftC; i <= RightC; i++)                                 // 在找到的峰的区间找到最大值和位置，即为真正的C峰与位置
            {
                if(bufP[i] >= PeakCVol)
                {
                    C_Location = i;
                    PeakCVol = bufP[C_Location];
                }
                C_max = PeakCVol;
            }
            if(Limit_C <= C_Location && C_Location <= Max_C)       // 如果位置符合C线位置
            {
                PeakCPos = C_Location;
                PeakCVol = C_max;
                int LeftT = C_Location- TC_DX - 90;
                int RightT = C_Location - TC_DX + 90;
                PeakTVol = 0;
                tMinVol = 1000000;
                for(int i = LeftT; i <= RightT; i++)
                {
                    if(bufP[i] >= PeakTVol)
                    {
                        PeakTPos = i;
                        PeakTVol = bufP[PeakTPos];
                    }
                }
                LeftT = PeakTPos;
                RightT = PeakCPos;
                for(int i = LeftT; i <= RightT; i++)
                {
                    if(bufP[i] <= tMinVol)
                    {
                        tMinPos = i;
                        tMinVol = bufP[tMinPos];
                    }
                }
                cMinVol = tMinVol;
            }
            else                                                                               // 如果位置不符合C线位置
            {
                Card_index[iPeakTimes] = true;
            }
        }
        else                                                                              // 找到多个峰
        {
//            qDebug() << "We have found times " <<  Peak_Lengh;
            FoundPeakVol Max_Peak[Peak_Lengh];
            memset(Max_Peak, 0, sizeof(Max_Peak));
            for(int index = 0; index < Peak_Lengh; index++)
            {
                QString PeakC = CPeak_times.at(index+1);
                QStringList CPeak_List = PeakC.split(",");
                int Lengh = CPeak_List.length() - 1;
                FoundPeakVol C_Peak[Lengh];
                memset(C_Peak, 0, sizeof(C_Peak));
                for(int i = 0; i <  Lengh; i++)
                {
                    C_Peak[i].ReadData = bufP[CPeak_List.at(i).toInt() * 10];
                    C_Peak[i].Location = CPeak_List.at(i).toInt() * 10;
                }
                Rank_Data(C_Peak, Lengh);
                int LeftC = C_Peak[0].Location - 20;
                int RightC = C_Peak[0].Location + 20;
                PeakCVol = 0;
                cMinVol =1000000;
                int  C_Location = 0;
                double C_max = 0;
                for(int i = LeftC; i <= RightC; i++)                                 // 在找到的峰的区间找到最大值和位置，即为真正的C峰与位置
                {
                    if(bufP[i] >= PeakCVol)
                    {
                        C_Location = i;
                        PeakCVol = bufP[C_Location];
                    }
                }
                C_max = PeakCVol;
                Max_Peak[index].Location = C_Location;
                Max_Peak[index].ReadData = C_max;
            }
            Rank_Data(Max_Peak, Peak_Lengh);
            PeakCPos = Max_Peak[0].Location;
            PeakCVol = Max_Peak[0].ReadData;
//            qDebug() << "======We have found the max Peak Location is " << Max_Peak[0].Location;
//            qDebug() << "======We have found the max Peak Data is " << Max_Peak[0].ReadData;
//            qDebug() << "=================== C_Location is " << PeakCPos;
//            qDebug() << "=================== Limit_C is " << Limit_C;
//            qDebug() << "=================== Max_C is " << Max_C;

            if(Limit_C <= PeakCPos && PeakCPos <= Max_C)
            {
                int LeftT = PeakCPos - TC_DX - 90;
                int RightT = PeakCPos - TC_DX + 90;
                PeakTVol = 0;
                tMinVol = 1000000;
                for(int i = LeftT; i <= RightT; i++)
                {
                    if(bufP[i] >= PeakTVol)
                    {
                        PeakTPos = i;
                        PeakTVol = bufP[PeakTPos];
                    }
                }
                LeftT = PeakTPos;
                RightT = PeakCPos;
                for(int i = LeftT; i <= RightT; i++)
                {
                    if(bufP[i] <= tMinVol)
                    {
                        tMinPos = i;
                        tMinVol = bufP[tMinPos];
                    }
                }
                cMinVol = tMinVol;
            }
            else
            {
//                qDebug() << "--------------have Error";
                Card_index[iPeakTimes] = true;
            }
        }

        //---------------------------------------------------------------------------------------------//
        CalcVol.TPeakPos = PeakTPos;                                 //  T线在最高值处的X轴位置
        CalcVol.CPeakPos = PeakCPos;                                //  C线在最高值处的X轴位置
        CalcVol.TPeakVol = PeakTVol-tMinVol;                    // T最终结果等于读值的最高值减去读值的最低值
        CalcVol.CPeakVol = PeakCVol-cMinVol;                   // C最终结果等于读值的最高值减去读值的最低值

//        qDebug("TPos=%d, TMinVol=%f, TVol=%f" ,PeakTPos,tMinVol,CalcVol.TPeakVol);
//        qDebug("CPos=%d, CMinVol=%f, CVol=%f",PeakCPos,cMinVol,CalcVol.CPeakVol);
//        qDebug() << "C-T =  " << PeakCPos - PeakTPos;
    }
    return true;
}