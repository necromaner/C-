//
// Created by necromaner on 2019-02-27.
//

bool APP_dev::agl_calc_buf(TlineClinePosStr TcPos,double *bufP, int Length, AdcCalcStr &CalcVol) {
    qDebug()<<"1.判断是否为AGL设备";
    //1.判断是否为AGL设备
    if (AppSta != AGL_DEV) {
        return false;
    }
    qDebug()<<"2.错误判断 Length不能小于1800";
    //2.错误判断 Length不能小于1800
    if (Length < 1800) {//Length为宏AdcMaxCycle 值为1800
//        qDebug() << "the adc data length is < 1800!";
        return false;
    }
    //3.
    if (isCalibration == true)       // 如果是C位置校准
    {
        qDebug() << "3.1.C位置校准";
        double cMinVol = 1000000;                 //C读值的最低值
        int PeakCPos = 1100;                      //C线在最高值处的X轴位置
        double PeakCVol = 0;                      //C读值的最高值

        int tMinPos = 1100;                       //T读值的最低值坐标
        double tMinVol = 1000000;                 //T读值的最低值
        int PeakTPos = 900;                       //T线在最高值处的X轴位置
        double PeakTVol = 0;                      //T读值的最高值
//        double Rank_Peak[1799] = {0};
//        for(int i = 0 ; i < 1799; i++)
//        {
//            Rank_Peak[i] = bufP[i+1] - bufP[i];
//        }

        qDebug() << "3.1.1.求平均数";
        double Samll_Peak[180] = {0};
        T1(&bufP[0],&Samll_Peak[0]);
        qDebug() << "3.1.2.60到169差值";
        //Samll_Rank为Samll_Peak的60到169与后面的差值
        double Samll_Rank[179] = {0};
        for (int i = 60; i < 170; i++)                            //   得到滤波之后曲线的倒数曲线
        {
            Samll_Rank[i] = Samll_Peak[i + 1] - Samll_Peak[i];
        }
//        for(int i=0;i<180;i++){
//            qDebug() <<Samll_Rank[i];
//        }
        //求序号为11到170的前5个数大于0的个数大于2，后5个数小于0的个数大于2的序号
        /*
         * 例：序号为11
         * 先求前5个  6  7  8  9 10 中从前到后连续大于0的个数，如果遇到0跳过，遇到负数终止
         * 如果个数大于1（不等于1）则求后5个，反正不求
         * 再求后5个 11 12 13 14 15 中从后到前连续小于0的个数，如果遇到0跳过，遇到正数终止
         * 如果个数大于1（不等于1）->(这种情况下前5个满足的数与后5个满足的数都大于2）
         * 记录满足的序号
         *
         * 记录方法：
         * 用","分割相邻的序号，用";"分割不相邻的序号（例: ";165,164,;157,156,;149,148,;141,140,;133,132,;125,124,;117,116,;109,108,;101,100,;93,92,;85,84,;77,76,;69,68,"
         * 在接近最高处的时候左边为上升趋势，所以后一个减前一个为正数
         * 在接近最高处的时候右边为下降趋势，所以后一个减前一个为负数
         *
         */
        qDebug() << "3.1.3.11到169求符合要求的数";
        QString Rank_str;//存放符合要求的数
        {//函数2
            int c_Left = 0;
            int c_Right = 0;
            int C_Lefttimes = 0;
            int C_Righttimes = 0;
            bool isCpeakOK = false;
            for (int i = 170; i > 10; i--)                            // 在滤波之后的曲线的倒数曲线寻找峰值点
            {

                C_Lefttimes = 0;
                C_Righttimes = 0;
                c_Left = i - 5;
                c_Right = i + 5;
                for (int j = c_Left; j < i; j++) {
                    if (Samll_Rank[j] > 0) {
                        C_Lefttimes++;
                    } else if (Samll_Rank[j] < 0) {
                        break;
                    }
                }
                if (C_Lefttimes > 1) {
                    for (int k = i; k < c_Right; k++) {
                        if (Samll_Rank[k] < 0) {
                            C_Righttimes++;
                        } else {
                            break;
                        }
                    }
                }
                if (C_Righttimes > 1) {
                    if (isCpeakOK == false) {
                        isCpeakOK = true;
                        Rank_str += ";";
                    }
                    Rank_str += QString::number(i) + ",";
                } else {
                    isCpeakOK = false;
                }
            }
        }
        qDebug() << "    -|We found Rank_str " << Rank_str;
        qDebug() << "3.1.4.分割找到峰值";
        int TC_DX = 350;
        int Limit_C = 900;
        int Max_C = 1680;

        QStringList CPeak_times = Rank_str.split(";");//用";"分割  ";"相隔的为符合要求的连续的点
        int Peak_Lengh = CPeak_times.length() - 1;              // 得到找到的符合范围的峰值点范围的次数
        //        for(int i=1;i<Peak_Lengh+1;i++){
        //            qDebug() << CPeak_times.at(i);
        //            /*
        //            "152,"
        //            "117,116,115,"
        //            "82,81,80,79,"
        //             */
        //        }
        qDebug() << "    -|Peak_Lengh :"<<Peak_Lengh;
        if (0 == Peak_Lengh)                                                     // 找到0个峰
        {
            qDebug() << "3.6.1.没有峰值";
//            qDebug() << "We have no found" ;
            tMinPos = 0;                                  //1  最小值的坐标（最大值与最大值坐标-350的左右180范围内的最大值之间的范围）
            tMinVol = 0;                                  //2  T读值的最低值

            PeakCPos = 0;                                 //3  C线在最高值处的X轴位置  求最大值的坐标
            PeakCVol = 0;                                 //4  C读值的最高值
            cMinVol  = 0;                                 //5  C读值的最低值
        } else if (1 == Peak_Lengh)                                             // 找到1个峰
        {
            qDebug() << "3.6.2.一个峰值";
            QString PeakData = CPeak_times.at(1);                           //获取第2组数据
            QStringList CPeak_List = PeakData.split(",");                   //用","分割
            Peak_Lengh = CPeak_List.length() - 1;//分割长度（0开始）
            FoundPeakVol C_Peak[Peak_Lengh];//创建Peak_Lengh个结构体
            memset(C_Peak, 0, sizeof(C_Peak));//将C_Peak初始化为0
            for (int i = 0; i < Peak_Lengh; i++) {//找到峰值范围中最左侧的坐标，C_Peak赋值采集值的坐标与对应值
                C_Peak[i].ReadData = bufP[CPeak_List.at(i).toInt() * 10];
                C_Peak[i].Location = CPeak_List.at(i).toInt() * 10;
            }
            Rank_Data(C_Peak, Peak_Lengh);//将C_Peak中的实际值从大到小进行排序
            int LeftC = C_Peak[0].Location - 20;//C_Peak左边20的坐标      最大值左边20
            int RightC = C_Peak[0].Location + 20;//C_Peak右边20的坐标     最大值右边20
            PeakCVol = 0;                                 //4  最大值
            cMinVol = 1000000;                             //5
            int C_Location = 0;           //最大值坐标
            double C_max = 0;              //最大值
            //C_max与PeakCVol得到范围中（最大值左右40的范围）的最大值  C_Location为范围中最大值坐标
            for (int i = LeftC; i <= RightC; i++)                    // 在找到的峰的区间找到最大值和位置，即为真正的C峰与位置
            {
                if (bufP[i] >= PeakCVol) {
                    C_Location = i;
                    PeakCVol = bufP[C_Location];
                }
                C_max = PeakCVol;
            }
            //Limit_C与Max_C为password中写的值，判断最大值是否在该范围内
            if (Limit_C <= C_Location && C_Location <= Max_C)       // 如果位置符合C线位置
            {
                PeakCPos = C_Location;//最大值坐标
                PeakCVol = C_max;     //最大值
                int LeftT = C_Location - TC_DX - 90;//最大值坐标-350 的左90的坐标
                int RightT = C_Location - TC_DX + 90;//最大值坐标-350 的右90的坐标
                PeakTVol = 0;
                tMinVol = 1000000;
                //PeakTVol为范围中（最大值-350 左右180的范围）最大值 PeakTPos找到的最大值坐标
                for (int i = LeftT; i <= RightT; i++) {//最大值坐标-350位置左右180的范围
                    if (bufP[i] >= PeakTVol) {
                        PeakTPos = i;
                        PeakTVol = bufP[PeakTPos];
                    }
                }
                LeftT = PeakTPos;//最大值-350 左右180的范围中的最大值
                RightT = PeakCPos;//最大值坐标
                //tMinPos最小值坐标   tMinVol最小值
                for (int i = LeftT; i <= RightT; i++) {//在最大值-350 左右180的范围中的最大值的坐标到最大值范围内找到最小值
                    if (bufP[i] <= tMinVol) {
                        tMinPos = i;
                        tMinVol = bufP[tMinPos];
                    }
                }
                cMinVol = tMinVol;
            } else {                            // 如果位置不符合C线位置   范围外
                qDebug() << "The Card is Error";
                return false;//差异
            }
        } else                                                        // 找到多个峰
        {
            qDebug("3.6.3.有%d个峰值",Peak_Lengh);
            QString CPeakstr;
            QString TPeakstr;
            double MaxData = 0;
            int MaxLocation = 0;
            qDebug()<<"3.6.3.1.循环多个峰值,找到各个峰的最大值";

            for (int index = 0; index < Peak_Lengh; index++) {//循环多个峰
                QString PeakC = CPeak_times.at(index + 1);
                QStringList CPeak_List = PeakC.split(",");
                int Lengh = CPeak_List.length() - 1;      //每个峰符合条件数（0开始）
//                qDebug("  -|1.循环第%d遍，有%d个符合条件个数",index,Lengh);
//                for(int i=0;i<Lengh;i++){
//                    qDebug() << "        -|"<<CPeak_List.at(i);
//                /*
//                   -|1.循环第0遍，有1个符合条件个数
//                      -| "152"
//                   -|1.循环第1遍，有3个符合条件个数
//                      -| "117"
//                      -| "116"
//                      -| "115"
//                   -|1.循环第2遍，有4个符合条件个数
//                      -| "82"
//                      -| "81"
//                      -| "80"
//                      -| "79"
//                 */
//                }

                FoundPeakVol C_Peak[Lengh];//结构体存放坐标和对应值 Location坐标 ReadData对应值
                memset(C_Peak, 0, sizeof(C_Peak));
                for (int i = 0; i < Lengh; i++){//找到峰值范围中最左侧的坐标，C_Peak赋值采集值的坐标与对应值
                    C_Peak[i].ReadData = bufP[CPeak_List.at(i).toInt() * 10];
                    C_Peak[i].Location = CPeak_List.at(i).toInt() * 10;
                }
                for(int i=0;i<Lengh;i++){
//                    qDebug()<<"      -|2.找到实际坐标及值 "<<C_Peak[i].Location<<C_Peak[i].ReadData;
                }
                Rank_Data(C_Peak, Lengh);//将C_Peak中的实际值从大到小进行排序
//                qDebug()<<"      -|3.小->大实际值排序";
//                for(int i=0;i<Lengh;i++){
//                    qDebug()<<"      -|3.小->大实际值排序 "<<C_Peak[i].Location<<C_Peak[i].ReadData;
//                }
                PeakCVol = 0;                                 //4  最大值
                cMinVol = 1000000;                             //5
                int C_Location = 0;           //最大值坐标
                {//函数3
                    //最靠近左边
                    int LeftC = C_Peak[0].Location - 20;//C_Peak左边20的坐标      最大值左边20
                    int RightC = C_Peak[0].Location + 20;//C_Peak右边20的坐标     最大值右边20
                    for (int i = LeftC; i <= RightC; i++)     // 在找到的峰的区间找到最大值和位置，即为真正的C峰与位置
                    {
                        if (bufP[i] >= PeakCVol) {
                            C_Location = i;
                            PeakCVol = bufP[C_Location];
                        }
                    }
                }
                MaxData = PeakCVol;//最大值
                MaxLocation = C_Location;//最大值坐标
//                qDebug()<<"      -|4.真正的最大值"<<MaxLocation<<MaxData;
                if (C_Peak[0].Location >= 1000) {//如果最大值坐标大于1000
                    CPeakstr += QString::number(MaxLocation) + ",";//最大值坐标，
                } else {
                    TPeakstr += QString::number(MaxLocation) + ",";
                }
            }
            QStringList ListPeakC = CPeakstr.split(",");//1508,1148,
            int CPeaktime = ListPeakC.length() - 1;//坐标大于1000的最大值数
            QStringList ListPeakT = TPeakstr.split(",");//792,
            int TPeaktime = ListPeakT.length() - 1;//坐标小于1000的最大值数
            qDebug("    -|坐标大于1000的数量 %d，值为 :%s",CPeaktime,qPrintable(CPeakstr));
            qDebug("    -|坐标小于1000的数量 %d，值为 :%s",TPeaktime,qPrintable(TPeakstr));
            qDebug()<<"3.6.3.2.找坐标大于1000和小于1000中的最大值";
            FoundPeakVol CPeakFound[CPeaktime];
            FoundPeakVol TPeakFound[TPeaktime];
            memset(CPeakFound, 0, sizeof(CPeakFound));
            memset(TPeakFound, 0, sizeof(TPeakFound));
            for (int i = 0; i < CPeaktime; i++) {
                CPeakFound[i].Location = ListPeakC.at(i).toInt();
                CPeakFound[i].ReadData = bufP[ListPeakC.at(i).toInt()];
            }
            for (int i = 0; i < TPeaktime; i++) {
                TPeakFound[i].Location = ListPeakT.at(i).toInt();
                TPeakFound[i].ReadData = bufP[ListPeakT.at(i).toInt()];
            }
            Rank_Data(CPeakFound, CPeaktime);
            Rank_Data(TPeakFound, TPeaktime);
            PeakCPos = CPeakFound[0].Location;//大于1000的最大值数 中最大值
            PeakTPos = TPeakFound[0].Location;//小于1000的最大值数 中最大值
            qDebug()<<"    -|大于1000中最大值坐标 "<<PeakCPos<<"值为"<<CPeakFound[0].ReadData;
            qDebug()<<"    -|小于1000中最大值坐标 "<<PeakTPos<<"值为"<<TPeakFound[0].ReadData;
            int TCDx = PeakCPos - PeakTPos;//1000左右两边最大值的差值
            QString TC_Dx = QString::number(TCDx);
            qDebug()<<"    -|坐标差值 "<<TC_Dx;
            if (!ReWriteFile("DX", TC_Dx)) {
//                qDebug() << "rewite error";
            }
            int CLocation = 1257;//1257
            int Cdistance = CLocation - PeakCPos;//1257-大于1000的最大值坐标 中最大值
            QString CDis_str = QString::number(Cdistance);
            qDebug()<<"    -|1257减大于1000的最大值坐标 "<<CDis_str;
            if (!ReWriteFile("C_Distance", CDis_str)) {
//                qDebug() << "3518 rewite error";
            }
        }
    } else {//非C线校准，读TC值
        qDebug() << "3.2.非C线校准，读TC值";
        bool ok = false;
        double cMinVol = 1000000;
        int PeakCPos = 1100;
        double PeakCVol = 0;
        int tMinPos = 1100;
        double tMinVol = 1000000;
        int PeakTPos = 900;
        double PeakTVol = 0;
//        double Rank_Peak[1799] = {0};
        //坐标平移 大于0向右  小于0向左
        int DX_c = 0;//0
        if (DX_c < 0) {
            for (int i = 0; i < 1800 + DX_c; i++) {
                bufP[i] = bufP[i - DX_c];
            }
            for (int i = 1800 + DX_c; i < 1800; i++) {//归0
                bufP[i] = 0;
            }
        } else if (DX_c > 0) {
            for (int i = 1799; i > DX_c; i--) { //平移数量到最后范围
                bufP[i] = bufP[i - DX_c];
            }
            for (int i = DX_c; i >= 0; i--) {//归0
                bufP[i] = 0;
            }
        }
//-------------------------------------------------------------------------------------//
//        for(int i = 0 ; i < 1799; i++)
//        {
//            Rank_Peak[i] = bufP[i+1] - bufP[i];
//        }
        qDebug() << "3.2.1.求平均数";
        double Samll_Peak[180] = {0};//平均数
        T1(&bufP[0],&Samll_Peak[0]);//求平均数
        qDebug() << "3.2.2.60到169差值";
        //Samll_Rank为Samll_Peak的60到169与后面的差值
        double Samll_Rank[179] = {0};
        for (int i = 60; i < 170; i++)                            //   得到滤波之后曲线的倒数曲线
        {
            Samll_Rank[i] = Samll_Peak[i + 1] - Samll_Peak[i];
        }
        //求序号为101到168的前5个数大于0的个数大于2，后5个数小于0的个数大于2的序号
        qDebug() << "3.2.3.101到168求符合要求的数";
        QString Rank_str;//存放符合要求的数
        {//函数2
            int c_Left = 0;
            int c_Right = 0;
            int C_Lefttimes = 0;
            int C_Righttimes = 0;
            bool isCpeakOK = false;
            for (int i = 168; i > 100; i--)                 // 在滤波之后的曲线的倒数曲线寻找峰值点
            {
                C_Lefttimes = 0;
                C_Righttimes = 0;
                c_Left = i - 5;
                c_Right = i + 5;
                for (int j = c_Left; j < i; j++) {
                    if (Samll_Rank[j] > 0) {
                        C_Lefttimes++;
                    } else if (Samll_Rank[j] < 0) {
                        break;
                    }
                }
                if (C_Lefttimes > 1) {
                    for (int k = i; k < c_Right; k++) {
                        if (Samll_Rank[k] < 0) {
                            C_Righttimes++;
                        } else {
                            break;
                        }
                    }
                }
                if (C_Righttimes > 1) {
                    if (isCpeakOK == false) {
                        isCpeakOK = true;
                        Rank_str += ";";
                    }
                    Rank_str += QString::number(i) + ",";
                } else {
                    isCpeakOK = false;
                }
            }
        }
        qDebug() << "    -|We found Rank_str " << Rank_str;

        qDebug() << "3.2.4.分割找到峰值";
//        bool ok = false;
        int TC_DX = 350;//350
        int Limit_C = 900;//900
        int Max_C = 1600;//1680
        QStringList CPeak_times = Rank_str.split(";");
        int Peak_Lengh = CPeak_times.length() - 1;              // 得到找到的符合范围的峰值点范围的次数
//        for(int i=1;i<Peak_Lengh+1;i++){
//                    qDebug() << CPeak_times.at(i);
//                    /*
//                      "152,"
//                      "117,116,115,"
//                     */
//        }
        qDebug() << "    -|Peak_Lengh :"<<Peak_Lengh;
        if (0 == Peak_Lengh)                                                     // 找到0个峰
        {
            qDebug() << "3.6.1.没有峰值";
            tMinPos = 0;                                  //1  最小值的坐标（最大值与最大值坐标-350的左右180范围内的最大值之间的范围）
            tMinVol = 0;                                  //2  最小值
            PeakCPos = 0;                                 //3  求最大值的坐标（passpord中的范围）
            PeakCVol = 0;                                 //4  最大值
            cMinVol = tMinVol = 0;                        //5
        } else if (1 == Peak_Lengh)                                             // 找到1个峰
        {
            qDebug() << "3.6.2.一个峰值";
            QString PeakData = CPeak_times.at(1);                           //获取第2组数据
            QStringList CPeak_List = PeakData.split(",");                   //用","分割
            Peak_Lengh = CPeak_List.length() - 1;//分割长度（0开始）
            FoundPeakVol C_Peak[Peak_Lengh];//创建Peak_Lengh个结构体
            memset(C_Peak, 0, sizeof(C_Peak));//将C_Peak初始化为0
            for (int i = 0; i < Peak_Lengh; i++) {//找到峰值范围中最左侧的坐标，C_Peak赋值采集值的坐标与对应值
                C_Peak[i].ReadData = bufP[CPeak_List.at(i).toInt() * 10];
                C_Peak[i].Location = CPeak_List.at(i).toInt() * 10;
            }
            Rank_Data(C_Peak, Peak_Lengh);//将C_Peak中的实际值从大到小进行排序
            int LeftC = C_Peak[0].Location - 20;//C_Peak左边20的坐标      最大值左边20
            int RightC = C_Peak[0].Location + 20;//C_Peak右边20的坐标     最大值右边20
            PeakCVol = 0;                                 //4  最大值
            cMinVol = 1000000;                             //5
            int C_Location = 0;           //最大值坐标
            double C_max = 0;              //最大值
            //C_max与PeakCVol得到范围中（最大值左右40的范围）的最大值  C_Location为范围中最大值坐标
            for (int i = LeftC; i <= RightC; i++)                    // 在找到的峰的区间找到最大值和位置，即为真正的C峰与位置
            {
                if (bufP[i] >= PeakCVol) {
                    C_Location = i;
                    PeakCVol = bufP[C_Location];
                }
                C_max = PeakCVol;
            }
            //Limit_C与Max_C为password中写的值，判断最大值是否在该范围内
            if (Limit_C <= C_Location && C_Location <= Max_C)       // 如果位置符合C线位置
            {
                PeakCPos = C_Location;//最大值坐标
                PeakCVol = C_max;     //最大值
                int LeftT = C_Location - TC_DX - 90;//最大值坐标-350 的左90的坐标
                int RightT = C_Location - TC_DX + 90;//最大值坐标-350 的右90的坐标
                PeakTVol = 0;
                tMinVol = 1000000;
                //PeakTVol为范围中（最大值-350 左右180的范围）最大值 PeakTPos找到的最大值坐标
                for (int i = LeftT; i <= RightT; i++) {//最大值坐标-350位置左右180的范围
                    if (bufP[i] >= PeakTVol) {
                        PeakTPos = i;
                        PeakTVol = bufP[PeakTPos];
                    }
                }
                LeftT = PeakTPos;//最大值-350 左右180的范围中的最大值
                RightT = PeakCPos;//最大值坐标
                //tMinPos最小值坐标   tMinVol最小值
                for (int i = LeftT; i <= RightT; i++) {//在最大值-350 左右180的范围中的最大值的坐标到最大值范围内找到最小值
                    if (bufP[i] <= tMinVol) {
                        tMinPos = i;
                        tMinVol = bufP[tMinPos];
                    }
                }
                cMinVol = tMinVol;
            } else {                            // 如果位置不符合C线位置   范围外
                qDebug() << "The Card is Error";
                Card_index[iPeakTimes] = true;//差异
            }
        } else                                                                              // 找到多个峰
        {
            qDebug("3.6.3.有%d个峰值",Peak_Lengh);
            FoundPeakVol Max_Peak[Peak_Lengh];
            memset(Max_Peak, 0, sizeof(Max_Peak));
            qDebug()<<"3.6.3.1.循环多个峰值,找到各个峰的最大值";

            for (int index = 0; index < Peak_Lengh; index++) {//循环多个峰
                QString PeakC = CPeak_times.at(index + 1);
                QStringList CPeak_List = PeakC.split(",");
                int Lengh = CPeak_List.length() - 1;      //每个峰符合条件数（0开始）
//                qDebug("  -|1.循环第%d遍，有%d个符合条件个数",index,Lengh);
//                for(int i=0;i<Lengh;i++){
//                    qDebug() << "        -|"<<CPeak_List.at(i);
//                /*
//                   -|1.循环第0遍，有1个符合条件个数
//                      -| "152"
//                   -|1.循环第1遍，有3个符合条件个数
//                      -| "117"
//                      -| "116"
//                      -| "115"
//                 */
//                }
                FoundPeakVol C_Peak[Lengh];
                memset(C_Peak, 0, sizeof(C_Peak));
                for (int i = 0; i < Lengh; i++) {
                    C_Peak[i].ReadData = bufP[CPeak_List.at(i).toInt() * 10];
                    C_Peak[i].Location = CPeak_List.at(i).toInt() * 10;
                }
                for(int i=0;i<Lengh;i++){
//                    qDebug()<<"      -|2.找到实际坐标及值 "<<C_Peak[i].Location<<C_Peak[i].ReadData;
                }
                Rank_Data(C_Peak, Lengh);//将C_Peak中的实际值从大到小进行排序
//                qDebug()<<"      -|3.小->大实际值排序";
//                for(int i=0;i<Lengh;i++){
//                    qDebug()<<"      -|3.小->大实际值排序 "<<C_Peak[i].Location<<C_Peak[i].ReadData;
//                }
                PeakCVol = 0;                                 //4  最大值
                cMinVol = 1000000;                            //5
                int C_Location = 0;           //最大值坐标
                double C_max = 0;
                {//函数3
                    //最靠近左边
                    int LeftC = C_Peak[0].Location - 20;//C_Peak左边20的坐标      最大值左边20
                    int RightC = C_Peak[0].Location + 20;//C_Peak右边20的坐标     最大值右边20
                    for (int i = LeftC; i <= RightC; i++)     // 在找到的峰的区间找到最大值和位置，即为真正的C峰与位置
                    {
                        if (bufP[i] >= PeakCVol) {
                            C_Location = i;
                            PeakCVol = bufP[C_Location];
                        }
                    }
                }

                C_max = PeakCVol;//最大值
                Max_Peak[index].Location = C_Location;//最大值坐标
                Max_Peak[index].ReadData = C_max;//最大值
//                qDebug()<<"      -|4.真正的最大值"<<Max_Peak[index].Location<<Max_Peak[index].ReadData;
                //真正的最大值 1148 132
            }
            qDebug()<<"3.6.3.2.找坐标大于1000中的最大值";
            Rank_Data(Max_Peak, Peak_Lengh);
            PeakCPos = Max_Peak[0].Location;
            PeakCVol = Max_Peak[0].ReadData;
            qDebug()<<"    -|大于1000中最大值坐标 "<<PeakCPos<<"值为"<<PeakCVol;

            //Limit_C与Max_C为password中写的值，判断最大值是否在该范围内
            if (Limit_C <= PeakCPos && PeakCPos <= Max_C) {      // 如果位置符合C线位置
                int LeftT = PeakCPos - TC_DX - 90;//最大值坐标-350 的左90的坐标
                int RightT = PeakCPos - TC_DX + 90;//最大值坐标-350 的右90的坐标
                PeakTVol = 0;
                tMinVol = 1000000;
                //PeakTVol为范围中（最大值-350 左右180的范围）最大值 PeakTPos找到的最大值坐标
                for (int i = LeftT; i <= RightT; i++) {//最大值坐标-350位置左右180的范围
                    if (bufP[i] >= PeakTVol) {
                        PeakTPos = i;
                        PeakTVol = bufP[PeakTPos];
                    }
                }
                LeftT = PeakTPos;//最大值-350 左右180的范围中的最大值
                RightT = PeakCPos;//最大值坐标
                //tMinPos最小值坐标   tMinVol最小值
                for (int i = LeftT; i <= RightT; i++) {//在最大值-350 左右180的范围中的最大值的坐标到最大值范围内找到最小值
                    if (bufP[i] <= tMinVol) {
                        tMinPos = i;
                        tMinVol = bufP[tMinPos];
                    }
                }
                cMinVol = tMinVol;
            } else {                            // 如果位置不符合C线位置   范围外
//                qDebug() << "--------------have Error";
                Card_index[iPeakTimes] = true;//差异
            }
        }

        //---------------------------------------------------------------------------------------------//
        CalcVol.TPeakPos = PeakTPos;                                 //  T线在最高值处的X轴位置
        CalcVol.CPeakPos = PeakCPos;                                //  C线在最高值处的X轴位置
        CalcVol.TPeakVol = PeakTVol - tMinVol;                    // T最终结果等于读值的最高值减去读值的最低值
        CalcVol.CPeakVol = PeakCVol - cMinVol;                   // C最终结果等于读值的最高值减去读值的最低值
//        TPos=1148, TMinVol=103.0, TVol= 29.0
//        CPos=1508, CMinVol=103.0, CVol= 45.0
//        C-T =   360
        qDebug("TPos=%d, TMinVol=%5.1f, TVol=%5.1f" ,PeakTPos,tMinVol,CalcVol.TPeakVol);
        qDebug("CPos=%d, CMinVol=%5.1f, CVol=%5.1f",PeakCPos,cMinVol,CalcVol.CPeakVol);
        qDebug() << "C-T =  " << PeakCPos - PeakTPos;
    }
    return true;
}
void Refactoring::T1(double *bufP,double *Samll_Peak) {//求前1800组每10个的平均数
    int iDiff = 0;
    double iSum = 0;
    int iDex = 0;
    //将前1800组数据每10个求平均数，传到Samll_Peak中
    for (int i = 0; i < 180; i++)                           //   将曲线原值进行滤波处理
    {
        iDiff = 1800 - iDex;
        if (iDiff > 10) {
            iDiff = 10;
        }
        iSum = 0;
        for (int j = i * 10; j < i * 10 + iDiff; j++) {
            iSum += bufP[j];
            Samll_Peak[i] = iSum / iDiff;
            iDex++;
        }
    }
//        for(int i=0;i<180;i++){
//            printf("%5.1f ",Samll_Peak[i]);
//        }
//        printf("\n");
}
